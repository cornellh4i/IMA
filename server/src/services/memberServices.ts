import { supabase } from "../supabase";
import {
  MEMBERS_TABLE,
  MemberFields,
  MemberRecord,
  MemberRole,
  SupabaseMemberRow,
} from "../models/member";

export interface MemberListFilters {
  roles?: MemberRole[];
  teams?: string[];
  joinedBefore?: string;
  joinedAfter?: string;
  search?: string;
  limit: number;
  offset: number;
}

export interface MemberListResult {
  members: MemberRecord[];
  count: number;
}

const escapeLikePattern = (value: string): string =>
  value.replace(/[%_]/g, (match) => `\\${match}`);

const mapRowToMember = (row: SupabaseMemberRow): MemberRecord => ({
  id: row.id,
  name: row.name,
  profile_picture: row.profile_picture ?? row.profile_picture ?? undefined,
  role: row.role,
  team: row.team,
  date_joined: row.date_joined ?? row.date_joined ?? "",
  email: row.email,
  linkedIn: row.linkedIn ?? row.linkedIn ?? undefined,
  bio: row.bio ?? undefined,
  created_at: row.created_at,
});

/**
 * Map a member to a Supabase row
 *
 * Does not include the id and created_at fields, as they are automatically generated by Supabase.
 *
 * @param member - The member to map
 * @returns The object conforming to the SupabaseMemberRow interface, save the id and created_at fields
 */
export const mapMemberToRow = (member: MemberFields) => ({
  name: member.name,
  profile_picture: member.profile_picture,
  role: member.role,
  team: member.team,
  date_joined: member.date_joined,
  email: member.email,
  linkedIn: member.linkedIn,
  bio: member.bio,
});

export const listMembers = async (
  filters: MemberListFilters
): Promise<MemberListResult> => {
  const { limit, offset } = filters;

  let query = supabase
    .from(MEMBERS_TABLE)
    .select("*", { count: "exact" })
    .range(offset, offset + limit - 1)
    .order("date_joined", { ascending: false });

  if (filters.roles && filters.roles.length > 0) {
    query = query.in("role", filters.roles);
  }

  if (filters.teams && filters.teams.length > 0) {
    query = query.in("team", filters.teams);
  }

  if (filters.joinedBefore) {
    query = query.lte("date_joined", filters.joinedBefore);
  }

  if (filters.joinedAfter) {
    query = query.gte("date_joined", filters.joinedAfter);
  }

  if (filters.search) {
    const pattern = `%${escapeLikePattern(filters.search)}%`;
    query = query.or(
      `name.ilike.${pattern},email.ilike.${pattern},bio.ilike.${pattern}`
    );
  }

  const { data, error, count } = await query;

  if (error) {
    throw new Error(error.message);
  }

  const members = (data ?? []).map(mapRowToMember);

  return {
    members,
    count: count ?? 0,
  };
};

/**
 * Get all members without pagination or filters
 * @returns Promise with all members
 */
export const getAllMembersService = async (): Promise<MemberRecord[]> => {
  const { data, error } = await supabase
    .from(MEMBERS_TABLE)
    .select("*")
    .order("date_joined", { ascending: false });

  if (error) {
    throw new Error(error.message);
  }

  return (data ?? []).map(mapRowToMember);
};

/**
 * Update a member by their unique ID
 * @param id - The unique identifier of the member to update
 * @param updates - The fields to update
 * @returns Promise with the updated member record
 */
export const updateMemberService = async (
  id: string,
  updates: Partial<MemberFields>
): Promise<MemberRecord> => {
  // Convert camelCase to snake_case for Supabase
  const supabaseUpdates: any = {};

  if (updates.profile_picture !== undefined) {
    supabaseUpdates.profile_picture = updates.profile_picture;
  }
  if (updates.date_joined !== undefined) {
    supabaseUpdates.date_joined = updates.date_joined;
  }
  if (updates.linkedIn !== undefined) {
    supabaseUpdates.linkedIn = updates.linkedIn;
  }
  if (updates.name !== undefined) {
    supabaseUpdates.name = updates.name;
  }
  if (updates.role !== undefined) {
    supabaseUpdates.role = updates.role;
  }
  if (updates.team !== undefined) {
    supabaseUpdates.team = updates.team;
  }
  if (updates.email !== undefined) {
    supabaseUpdates.email = updates.email;
  }
  if (updates.bio !== undefined) {
    supabaseUpdates.bio = updates.bio;
  }

  const { data, error } = await supabase
    .from(MEMBERS_TABLE)
    .update(supabaseUpdates)
    .eq("id", id)
    .select("*")
    .single();

  if (error) {
    throw new Error(error.message);
  }

  if (!data) {
    throw new Error("Member not found");
  }

  return mapRowToMember(data);
};
